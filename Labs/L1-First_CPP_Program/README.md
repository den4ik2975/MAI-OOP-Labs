# Аннотация
Обзор алгоритма, решающего задачу за `O(log(n))`, благодаря использованию приколов двоичной сс.
# Как работает алгоритм?
### Обзор функций
`getOnes(long long n):`

Эта функция считает общее количество единиц в двоичном представлении всех чисел от 0 до n включительно.

`countOnes(long long a, long long b):`

Эта функция использует `getOnes()` для подсчета количества единиц в диапазоне чисел от a до b включительно.
### Обзор подсчета
1.  Находим наибольшую степень двойки, не превышающую `n`
2. Подсчет единиц:
    - `(bitPosition * powerOf2 / 2)` - количество единиц до найденной степени двойки.
    - `(n - powerOf2 + 1)` - количество дополнительных единиц в старшем разряде для чисел от powerOf2 до n.
    - `getOnes(n - powerOf2)` - рекурсивный вызов для подсчета оставшихся единиц.
3. Функция `countOnes(a, b)` использует `getOnes()` для подсчета разницы между количеством единиц до `b` и до `(a-1)`, что дает количество единиц в диапазоне `[a, b]`.
### Пример

Теперь разберем работу `getOnes(13)`:

1. `n = 13` (`1101` в двоичной системе)
2. `powerOf2` начинается с 1 и удваивается, пока не превысит `n`:
   `1 -> 2 -> 4 -> 8` (останавливаемся здесь, так как 16 > 13)
3. `bitPosition = 3` (потому что мы сделали 3 сдвига)
4. Теперь вычисляем:
    - `(bitPosition * powerOf2 / 2) = (3 * 8 / 2) = 12`
    - `(n - powerOf2 + 1) = (13 - 8 + 1) = 6`
    - `getOnes(n - powerOf2) = getOnes(5)`

Для `getOnes(5)`:
1. `powerOf2: 1 -> 2 -> 4`
2. `bitPosition = 2` (потому что мы сделали 2 сдвига)
3. Вычисляем:
    - `(bitPosition * powerOf2 / 2) = (2 * 4 / 2) = 4`
    - `(n - powerOf2 + 1) = (5 - 4 + 1) = 2 `
    - `getOnes(1)`

Для `getOnes(1)`:
1. Мне лень расписывать много, поэтому: `powerOf2 = 1, bitPosition = 0`.
2. `(0 * 2 / 2) + (1 - 1 + 1) + getOnes(0)`

Ну и `getOnes(0) = 0`


> Итого: 18 + 6 + 1 + 0 = 25
### Посмотрим на рисунке
###### Вызов `getOnes(13)`

```
0-7:                   0 │ 000 ❮──
                       0 │ 001 ❮── Единицы здесь
                       0 │ 010 ❮── считаются с помощью
                       0 │ 011 ❮── (bitPosition * powerOf2 / 2)
                       0 │ 100 ❮── 
                       0 │ 101 ❮──
                       0 │ 110 ❮──
                       0 │ 111 ❮── // 12
─────────────────────────┼─────────────────────────────────────
8-13:              ──❯ 1 │ 000 ❮──
       Эти единицы ──❯ 1 │ 001 ❮── Числа здесь
         считаются ──❯ 1 │ 010 ❮── будут обработаны при
         с помощью ──❯ 1 │ 011 ❮── рекусии getOnes(5)
(n - powerOf2 + 1) ──❯ 1 │ 100 ❮──
              6 \\ ──❯ 1 │ 101 ❮──
```
Почему формула `(bitPosition * powerOf2 / 2)` работает?
- В каждом разряде половина чисел это 1, а вторая половина - 0.
- Количество чисел до `powerOf2` равно самому `powerOf2`.
- Поэтому в каждом разряде `powerOf2 / 2` единиц.
- Всего разрядов `bitPosition`
> Важно! *Так работает только со степенями двойки*, поэтому мы их и ищем

Почему формула `(n - powerOf2 + 1)` работает?
- Так как `powerOf2` максимально близкая степень двойки к `n`, то все старшие биты после `powerOf2` будут единицей
- Теперь нам нужно понять, сколько чисел влезают между `n` и `powerOf2`, как раз и получается формула

###### Вызов `getOnes(5)`
У нас после первого вызова остались до конца необработанными числа 8-13. Но после "отрезания" крайних единичек, они превратились в 0-5 
```
1-4:                    0│00 ❮──
                        0│01 ❮── (bitPosition * powerOf2 / 2)
                        0│10 ❮── 
                        0│11 ❮── // 4
 ────────────────────────┼────────────────────────────────────
5-6:           2 \\ ──❯ 1│00 
 (n - powerOf2 + 1) ──❯ 1│01 ❮── getOnes(1)
```
Ну а с `getOnes(1)` думаю и так понятно.

---
Действительно, сумма всех единиц равна 25.

Ну а функция `countOnes(a, b)` использует этот принцип для подсчета единиц в заданном диапазоне. Например, `countOnes(10, 13)` вычислит `getOnes(13) - getOnes(9)`, что даст количество единиц в числах `10, 11, 12 и 13`.
# Финал
Этот алгоритм работает эффективно, используя рекурсию и свойства двоичной системы счисления для быстрого подсчета единиц без необходимости перебирать каждое число в диапазоне.